{"version":3,"sources":["api/util.js","api/api.js","api/main.js","components/GameBoard.js","App.js","reportWebVitals.js","index.js"],"names":["random_choice","array","Math","floor","random","length","create_table","rows","columns","table","document","createElement","tbody","i","tr","j","td","appendChild","Color","RED","YELLOW","GREEN","BLUE","WordStatus","HOLDING","DEFERED","PLAYED","DISCARDED","PlayStatus","Category","name","color","image","is_wild","this","toLowerCase","Word","word","category","Team","curr_category","undefined","total_wins","final_turn","turns","Deck","unplayed","played","categories","console","log","util","set","get","Array","from","delete","push","Turn","team","deck","words","Map","Object","values","map","status","_draw_word","draw_from","from_status","to_status","temp_word","shift","index","indexOf","splice","num_cards_held","_draw_and_hold","_move_word","to_category","_release_and_draw","Game","teams","object","max_cycles","max_held","curr_turn_num","curr_team","curr_turn","interval","game_over","import_json","arrange_segments","category_key","categories_map","Set","keys","wild_category","import_categories","import_words","wild_position","segments","ordered","init_turn","timer","curr_team_num","cards","getElementById","node","innerText","JSON","stringify","obj","key","value","prepend","window","clearInterval","end_turn","update_team_wins","check_end_game","end_game","update_team","advance_turn","discard_word","win_word","defer_word","wins","num_turns","calculate_cycle","calculate_category","current_word","start_game","json_deck","num_teams","max_rounds","parseInt","api","create_test_teams","game","start","categoryColours","GameBoard","props","useState","gameState","current_word_text","current_word_category","currCards","setCards","timeLeft","setTimeLeft","turnStatus","setTurnStatus","playStatus","setPlayStatus","numTeams","numCategories","numRows","numCols","cols","createGrid","forEach","row","buildCounter","initialiseTable","categoryTable","setCategoryTable","useEffect","setTimeout","teamNumber","final_string","writeFinal","categoryNumber","roundNumber","moveTeam","winCard","deferCard","onSwipe","direction","onReadyTurn","clearTime","clearTimeout","tableData","handleKeyPress","useCallback","event","current","max","className","styles","buildStyles","pathColor","minValue","maxValue","strokeWidth","strokeLinecap","trailColor","addEventListener","removeEventListener","rowData","cellData","current_team_wins","get_last_wins","card","preventSwipe","style","backgroundColor","Button","id","onClick","variant","size","location","reload","App","setGame","setNumTeams","ButtonGroup","toggle","radio","idx","ToggleButton","type","checked","onChange","e","currentTarget","main","restartGame","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.c4560d8a.chunk.js","sourcesContent":["export function random_choice(array) {\n    return array[Math.floor(Math.random() * array.length)];\n}\n\nexport function wild_category(Category) {\n    const keys = Object.keys(Category);\n    keys.splice(Category.WILD, 1);\n    return Category[random_choice(keys)];\n};\n\nexport function choice_from_set(set) {\n    return random_choice(Array.from(set));\n};\n\nexport function shuffle(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array;\n};\n\nexport function map_to_object(map) {\n    const obj = {};\n    for (const [key, value] of map) {\n        obj[key] = value;\n    }\n    return obj;\n};\n\nexport function create_table(rows, columns) {\n    const table = document.createElement('table');\n    const tbody = document.createElement('tbody');\n    for (let i = 0; i < rows; i++) {\n        const tr = document.createElement('tr');\n        for (let j = 0; j < columns; j++) {\n            const td = document.createElement('td');\n            tr.appendChild(td);\n        }\n        tbody.appendChild(tr);\n    }\n    table.appendChild(tbody);\n    return table;\n}\n","import * as util from './util.js';\n\nconst DEFAULT_NUM_CATEGORIES = 7;\nconst DEFAULT_MAX_CYCLES = 1;//6\nconst DEFAULT_MAX_HELD = 2;\nconst DEFAULT_MAX_TEAMS = 4;\nconst DEFAULT_TIMER_SECONDS = 120;\nconst SECOND_IN_MILLISECONDS = 1000;\n\nexport const Color = {\n    RED: \"#ff0000\",\n    YELLOW: \"#ffff00\",\n    GREEN: \"#00ff00\",\n    BLUE: \"#0000ff\"\n}\n\nexport const WordStatus = {\n    HOLDING: \"holding\",\n    DEFERED: \"defered\",\n    PLAYED: \"played\",\n    DISCARDED: \"discarded\"\n}\n\nexport const PlayStatus = {\n    PREPARING: 0,\n    PLAYING: 1,\n    ENDED: 2\n}\n\nexport class Category {\n    constructor(name, color, image, is_wild) {\n        this.name = name.toLowerCase();\n        this.color = color;\n        this.image = image;\n        this.is_wild = is_wild;\n    }\n}\n\nexport class Sections {\n\n    constructor(categories, wild_position) {\n\n    }\n\n    wild() {\n\n    }\n\n    get(i) {\n        return [i];\n    }\n}\n\nexport class Word {\n    constructor(word, category) {\n        this.word = word;\n        this.category = category;\n    }\n}\n\nexport class Team {\n    constructor(name, color) {\n        this.name = name;\n        this.color = color;\n        this.curr_category = undefined;\n        this.total_wins = 0;\n        this.final_turn = false;\n        this.turns = [];\n    }\n}\n\nexport class Deck {\n\n    constructor(unplayed) {\n        this.unplayed = unplayed;\n        this.played = [];\n    }\n\n    draw_from(category, categories) {\n        console.log(category);\n        if (category.is_wild === true) {\n            category = util.random_choice(categories);\n        }\n\n        console.log(category);\n        const word = util.choice_from_set(this.unplayed.get(category));\n\n        this.unplayed.get(category).delete(word);\n\n        this.played.push(word);\n\n        return word;\n    }\n\n\n}\n\nexport class Turn {\n    constructor(team, category, deck, categories) {\n        this.team = team;\n        this.category = category;\n        this.deck = deck;\n        this.words = new Map(\n                Object.values(WordStatus).map(status => [status, []])\n                );\n        this.status = PlayStatus.PREPARING;\n        //this.timer = DEFAULT_TIMER_SECONDS;\n        this.categories = categories;\n\n        this._draw_word();\n    }\n\n    get wins() {\n        return this.words.get(WordStatus.PLAYED).length;\n    }\n\n\n    _draw_and_hold() {\n        const word = this.deck.draw_from(this.category, this.categories);\n        this.words.get(WordStatus.HOLDING).push(word);\n    }\n\n    _move_word(from_status, to_status, word) {\n        let temp_word = undefined;\n        if (word === undefined) {\n            temp_word = this.words.get(from_status).shift();\n        } else {\n            const index = this.words.get(from_status).indexOf(word);\n            temp_word = this.words.get(from_status).splice(index, 1);\n        }\n        this.words.get(to_status).push(temp_word);\n    }\n\n    _draw_word() {\n\n        // don't draw if we're preparing and we're already holding a word\n        if (\n                this.status === PlayStatus.PREPARING\n                && this.words.get(WordStatus.HOLDING).length !== 0\n           ) {\n            return;\n        }\n\n        // don't draw if it's the final turn and we've already won a word\n        if (\n                this.team.final_turn === true\n                && this.words.get(WordStatus.PLAYED).length > 0\n           ) {\n            return;\n        }\n\n        // don't draw if it's the final turn and we're already holding a word\n        if (\n                this.team.final_turn === true\n                && this.words.get(WordStatus.HOLDING).length !== 0\n           ) {\n            return;\n        }\n\n        const num_cards_held = (\n                this.words.get(WordStatus.DEFERED).length\n                + this.words.get(WordStatus.HOLDING).length\n                );\n\n        if (num_cards_held === 0) {\n            this._draw_and_hold();\n            return;\n        }\n\n        if (num_cards_held < DEFAULT_MAX_HELD) {\n            this._draw_and_hold();\n        } else {\n            this._move_word(WordStatus.DEFERED, WordStatus.HOLDING);\n        }\n    }\n\n    _release_and_draw(to_category, word) {\n        // stop letting cards be drawn when the game is over\n        this._move_word(WordStatus.HOLDING, to_category, word);\n        this._draw_word();\n    }\n\n    discard_word(word = undefined) {\n        this._release_and_draw(WordStatus.DISCARDED, word);\n    }\n\n    win_word(word = undefined) {\n        this._release_and_draw(WordStatus.PLAYED, word);\n    }\n\n    defer_word(word = undefined) {\n        // TODO: allow defering on the final turn?\n        this._release_and_draw(WordStatus.DEFERED, word);\n    }\n}\n\nexport class Game {\n\n    constructor(\n            teams,\n            object,\n            max_cycles = DEFAULT_MAX_CYCLES,\n            max_held = DEFAULT_MAX_HELD\n            ) {\n        this.teams = teams;\n        this.max_cycles = max_cycles;\n        this.max_held = max_held;\n        this.turns = [];\n        this.curr_turn_num = 0;\n        this.curr_team = undefined;\n        this.curr_turn = undefined;\n        this.interval = undefined;\n        this.game_over = false;\n\n        this.import_json(object);\n        this.arrange_segments(2);\n    }\n\n    import_words(object) {\n        const unplayed = new Map();\n\n        for (const category_key of Object.keys(object)) {\n\n            let category = this.categories_map.get(category_key);\n\n            unplayed.set(\n                    category,\n                    new Set(\n                        object[category_key].map(\n                            word => new Word(word, category)\n                            )\n                        )\n                    )\n        }\n\n        this.deck = new Deck(unplayed);\n    }\n\n    import_categories(object) {\n\n        this.categories = [];\n        this.categories_map = new Map();\n\n        for (const category_key of Object.keys(object)) {\n            let category = new Category(category_key);\n            // more logic for other data\n            this.categories_map.set(category_key, category);\n            this.categories.push(category);\n        }\n\n        // hard coded for wild\n        this.wild_category = new Category(\"wild\", undefined, undefined, true);\n\n    }\n\n    import_json(object) {\n        this.import_categories(object);\n        this.import_words(object);\n    }\n\n    arrange_segments(wild_position) {\n        this.segments = [...this.categories];\n        if (wild_position !== undefined) {\n            this.segments.splice(wild_position, 0, this.wild_category);\n        }\n    }\n\n    start(ordered) {\n        // Probably don't need this practically\n        if (ordered === false) {\n            util.shuffle(this.teams);\n        }\n        for (const team of this.teams) {\n            team.curr_category = this.segments[0];\n        }\n        this.init_turn();\n    }\n\n    get turn_timer() {\n        return this.curr_turn.timer;\n    }\n\n    get curr_team_num() {\n        return this.curr_turn_num % this.teams.length;\n    }\n\n    init_turn() {\n        this.curr_team = this.teams[this.curr_team_num];\n        this.curr_turn = new Turn(\n                this.curr_team,\n                //redundant?\n                (\n                 (this.curr_team.final_turn === true) ?\n                 this.wild_category : this.curr_team.curr_category\n                ),\n                this.deck,\n                this.categories\n                );\n        this.turns.push(this.curr_turn);\n        // this.show_words();\n    }\n\n    show_words() {\n        let cards = document.getElementById(\"words\");\n        let node = document.createElement(\"p\");\n        node.innerText = JSON.stringify(\n                util.map_to_object(this.curr_turn.words),\n                null,\n                1\n                );\n        cards.prepend(node);\n    }\n\n    tick_timer() {\n        if (this.curr_turn.timer > 0) {\n            this.curr_turn.timer--;\n        } else {\n            window.clearInterval(this.interval);\n            this.end_turn();\n        }\n\n    }\n\n    start_turn() {\n        this.curr_turn.status = PlayStatus.PLAYING;\n        //this.interval = window.setInterval( () => this.tick_timer() , 1 * SECOND_IN_MILLISECONDS);\n        //this.interval = window.setInterval(function() { this.tick_timer.bind(this) }, 1 * SECOND_IN_MILLISECONDS);\n        //window.setInterval(this.end, DEFAULT_TIMER_SECONDS * SECOND_IN_MILLISECONDS);\n    }\n\n    end_turn() {\n        console.log(\"Times up!\");\n        //this.curr_turn.timer = 0;\n        this.curr_turn.status = PlayStatus.ENDED;\n        this.update_team_wins();\n\n        if (this.check_end_game() === true) {\n            this.end_game();\n        } else {\n            this.update_team();\n            this.advance_turn();\n            this.init_turn();\n        }\n\n    }\n\n    discard_word() {\n        if (this.curr_turn.team.final_turn === true) {\n            this.end_turn();\n        } else {\n            this.curr_turn.discard_word();\n        }\n        // this.show_words();\n    }\n\n    win_word() {\n        console.log('clicked win')\n        this.curr_turn.win_word();\n        if (this.curr_turn.team.final_turn === true) {\n            this.end_turn();\n        }\n    }\n\n    defer_word() {\n        if (this.curr_turn.team.final_turn === true) {\n            this.end_turn();\n        } else {\n            this.curr_turn.defer_word();\n        }\n        // this.show_words();\n    }\n\n    update_team_wins() {\n        const wins = this.curr_turn.wins;\n        console.log(`${this.curr_team.name} scored ${wins}`);\n        this.curr_team.total_wins += wins;\n    }\n    get_last_wins() {\n        const num_turns = this.turns.length;\n        if (num_turns === 1) return 0;\n\n        const last_turn = this.turns[num_turns - 2];\n        return last_turn.wins;\n    }\n    get_last_team() {\n        const num_turns = this.turns.length;\n        if (num_turns === 1) return null;\n\n        const last_turn = this.turns[num_turns - 2];\n        return last_turn.team.name;\n    }\n\n    check_end_game() {\n        return this.curr_team.final_turn && this.curr_turn.wins > 0;\n    }\n\n    update_team() {\n        if (this.calculate_cycle(this.curr_team.total_wins) >= this.max_cycles) {\n            this.curr_team.final_turn = true;\n            this.curr_team.curr_category = this.wild_category;\n        } else {\n            this.curr_team.curr_category = this.calculate_category(this.curr_team.total_wins);\n        }\n    }\n\n    calculate_category(total_wins) {\n        return this.segments[total_wins % this.segments.length];\n    }\n\n    calculate_cycle(total_wins) {\n        return Math.floor(total_wins / this.segments.length);\n    }\n\n    advance_turn() {\n        this.curr_turn_num += 1;\n    }\n\n    end_game() {\n        console.log(this.curr_team.name + \" won!\");\n        this.game_over = true;\n    }\n\n    create_category_table() {\n        return util.create_table(this.teams.length, this.segments.length);\n    }\n\n    create_position_table() {\n        return util.create_table(this.teams.length, this.max_cycles);\n    }\n\n    get current_word() {\n        if (this.curr_turn == null) {\n            return undefined;\n        } else {\n            return this.curr_turn.words.get(WordStatus.HOLDING)[0];\n        }\n    }\n\n    get current_word_text() {\n        const word = this.current_word;\n        if (word == null) {\n            return undefined;\n        } else {\n            return word.word;\n        }\n    }\n\n    get current_word_category() {\n        const word = this.current_word;\n        if (word == null) {\n            return undefined;\n        } else {\n            return word.category.name;\n        }\n    }\n\n    get segment_names() {\n        if (this.segments == null) {\n            return undefined;\n        } else {\n            return this.segments.map(category => category.name);\n        }\n    }\n\n    get current_team_wins() {\n        return this.curr_turn.wins;\n    }\n\n}\n","import * as api from './api.js';\nimport * as ui from './ui.js';\n\n/*\n * TODO\n * Game state:\n * for each team:\n * \tcurrent category\n * \tcurrent wins\n * \ttotal wins\n * \tname\n * \tcolor\n */\n\nfunction import_deck(json_deck) {\n\n    console.log(json_deck)\n        //return Deck.from_json(json_deck)\n}\n\nfunction create_teams() {\n    const num_teams = parseInt(prompt(\"How many teams?: \", \"\"));\n    let teams = [];\n    for (let i = 0; i < num_teams; i++) {\n        const name = prompt(\"Enter Team name: \", \"\");\n        teams.push(new api.Team(name, Object.values(api.Color)[i]));\n    }\n    return teams;\n}\n\nfunction create_test_teams(num_teams) {\n    // const num_teams = 2;\n    var num_teams = parseInt(num_teams);\n    //const num_teams = parseInt(prompt(\"How many teams?: \", \"\"));\n    let teams = [];\n    for (let i = 0; i < num_teams; i++) {\n        const name = `Team ${i+1}`;\n        //const name = prompt(\"Enter Team name: \", \"\");\n        teams.push(new api.Team(name, Object.values(api.Color)[i]));\n    }\n    return teams;\n}\n\nexport function start_game(json_deck, num_teams, max_rounds) {\n\n    const teams = create_test_teams(num_teams);\n    const game = new api.Game(teams, json_deck, max_rounds);\n\n    // let button = document.getElementById(\"start\");\n    // button.style.display = \"none\";\n\n    // TODO\n    //const interval = window.setInterval(function() {ui.update_screen(game)}, 100);\n    //window.requestAnimationFrame(function() {update_timer(game)});\n    //category.appendChild(game.create_category_table());\n\n    //const position = document.getElementById('position');\n    //position.appendChild(game.create_position_table());\n\n    game.start();\n\n    return game;\n\n}\n","\nimport './GameBoard.css';\nimport Button from 'react-bootstrap/Button';\nimport { useState, useEffect, useCallback } from \"react\";\nimport TinderCard from 'react-tinder-card'\nimport {\n    CircularProgressbar,\n    CircularProgressbarWithChildren,\n    buildStyles\n} from \"react-circular-progressbar\";\nimport \"react-circular-progressbar/dist/styles.css\";\n\nconst categoryColours = {\n    'object': '#0099DA',\n    'action': '#F37027',\n    'wild': '#FFFFFF',\n    'world': '#016FA5',\n    'person': '#FFCB04',\n    'random': '#ED1C24',\n    'nature': '#008752',\n}\n\n\nexport default function GameBoard(props) {\n    const [currCards, setCards] = useState([{\n        word: props.gameState.current_word_text,\n        category: props.gameState.current_word_category\n    }])\n    const [timeLeft, setTimeLeft] = useState(-1);\n    const [turnStatus, setTurnStatus] = useState(false);\n    const [playStatus, setPlayStatus] = useState(false);\n    const [categoryTable, setCategoryTable] = useState(initialiseTable(props.numTeams, 7));\n\n    var timer;\n\n    useEffect(() => {\n        if (timeLeft > 0) {\n            timer = setTimeout(() => {\n                setTimeLeft(timeLeft - 1)\n            }, 1000);\n        }\n        else if (timeLeft == 0 && playStatus == true) {\n            // endTurn();\n            setPlayStatus(false);\n        }\n    }, [timeLeft]);\n\n    useEffect(() => {\n        if (playStatus == true) {\n            // unlimited time on final turn\n            if (!props.gameState.curr_team.final_turn) {\n                setTimeLeft(30);\n            }\n        }\n        // prevent ending turn on first default set\n        else if (playStatus == false && timeLeft != -1) {\n            props.gameState.end_turn(); // ends the turn in backend\n            updateTable(categoryTable, props.gameState.teams);\n            setTurnStatus(false);\n        }\n        else {\n            console.log('play status changed to ', playStatus);\n        }\n    }, [playStatus]);\n\n    const startTurn = () => {\n        setTurnStatus(true);\n        setCards([{\n            word: props.gameState.current_word_text,\n            category: props.gameState.current_word_category\n        }])\n    }\n    const winCard = () => {\n        props.gameState.win_word();\n        setCards([{\n            word: props.gameState.current_word_text,\n            category: props.gameState.current_word_category\n        }])\n\n        if (props.gameState.game_over) {\n            console.log('game over')\n        }\n    }\n    const deferCard = () => {\n        props.gameState.defer_word();\n        setCards([{\n            word: props.gameState.current_word_text,\n            category: props.gameState.current_word_category\n        }])\n    }\n    const restartGame = () => {\n        window.location.reload(false);\n    }\n\n    const onSwipe = (direction) => {\n        // disable if not current in a round\n        console.log('play status', playStatus);\n        // if (props.gameState.curr_team.final_turn) return;\n\n        if (direction === 'right') {\n            winCard();\n        }\n        // cannot defer if final turn\n        if (direction === 'left' && !props.gameState.curr_team.final_turn) {\n            deferCard();\n        }\n    }\n\n    const onReadyTurn = (direction) => {\n        if (direction === 'right') {\n            startTurn();\n        }\n    }\n\n    const clearTime = () => {\n        setTimeLeft(0); // this causes the game to end turn due to useEffect\n        clearTimeout(timer);\n    }\n\n    function createTable(tableData) {\n     return (\n      <table>\n       <tbody>\n       {\n        tableData.map(\n            (rowData, i) => {\n              return (\n                <tr className={`${props.gameState.curr_team_num == i ? \"active\": \"inactive\"}`}>\n                  {\n                    rowData.map(\n                        (cellData, j) => {\n                      return (\n                        <td className={`cell team-${i} ${Object.keys(categoryColours)[j]}`}\n                        > {cellData} </td>);\n                   })\n                  }\n                </tr>\n            );\n        })\n       }\n      </tbody>\n      </table>\n     )\n    }\n\n    function initialiseTable(numTeams, numCategories) {\n        let table = createGrid(numTeams, numCategories);\n        table.forEach(\n            row => row[0] = buildCounter(0, props.gameState.max_cycles)\n        );\n        return table;\n    }\n\n    function updateTable(table, teams) {\n        teams.forEach(\n            (team, i) =>\n            team.final_turn\n            ? writeFinal(table, i)\n            : moveTeam(table, i, team.total_wins % 7, Math.floor(team.total_wins / 7))\n        )\n        setCategoryTable(table);\n    }\n\n    function writeFinal(table, teamNumber) {\n        const final_string = \"*FINAL*\";\n        table[teamNumber].forEach(\n            (value, i, array) =>\n            array[i] = final_string[i]\n        );\n    }\n\n    function moveTeam(table, teamNumber, categoryNumber, roundNumber) {\n        table[teamNumber].forEach(\n            (value, i, array) =>\n            array[i] = (\n                i === categoryNumber\n                ? (\n                    roundNumber === props.gameState.max_cycles\n                    ? \"*\"\n                    //: `${roundNumber}/${props.gameState.max_cycles}`\n                    : buildCounter(roundNumber, props.gameState.max_cycles)\n\n                )\n                : undefined\n            )\n        );\n    }\n\n    const handleKeyPress = useCallback((event) => {\n        switch (event.key) {\n            case \"d\":\n                console.log(props.gameState);\n                break;\n            case \"ArrowRight\":\n                winCard();\n                break;\n            case \"ArrowLeft\":\n                deferCard();\n                break;\n            case \"ArrowDown\":\n                clearTime();\n                break;\n            case \"ArrowUp\":\n                setPlayStatus(true);\n                break;\n            default:\n                console.log(`${event.key} was pressed`);\n        }\n    }, []);\n\n    useEffect(() => {\n        document.addEventListener(\"keydown\", handleKeyPress, false);\n\n        return () => {\n            document.removeEventListener(\"keydown\", handleKeyPress, false);\n        };\n    }, []);\n\n    function buildCounter(current, max) {\n        return (\n            <div className=\"player\">\n                <CircularProgressbarWithChildren\n                    styles={buildStyles({\n                        pathColor: \"white\"\n                    })}\n                >\n                    <CircularProgressbar\n                        minValue={0}\n                        maxValue={max}\n                        value={current}\n                        strokeWidth={50}\n                        styles={buildStyles({\n                            strokeLinecap: \"butt\",\n                            pathColor: \"white\",\n                            trailColor: \"transparent\"\n                        })}\n                    />\n                </CircularProgressbarWithChildren>\n            </div>\n        )\n    }\n\n    return (\n        <div className=\"root\">\n            {/* <Button onClick={() => console.log(props.gameState)} variant=\"warning\">Print Game State</Button> */}\n\n            {(turnStatus === false || props.gameState.game_over) &&\n            <div className=\"board\">\n                {createTable(categoryTable)}\n            </div>\n            }\n            {/* <div className=\"team-div\" >\n                {props.gameState.teams.map((team, idx) => (\n                    <div className=\"team-header\" key={idx}>\n                        <p>{team.name} </p>\n                        <p>{team.total_wins}</p>\n                    </div>\n                ))}\n            </div> */}\n            {!props.gameState.game_over && (\n                playStatus === true && turnStatus === true ?\n                    <div className=\"round-view round-div\">\n                        <p className=\"timer-text\">{props.gameState.curr_team.final_turn ? '∞': timeLeft}</p>\n                        <p className=\"score-text\">{props.gameState.curr_team.final_turn ? 'Anybody can answer': `Current Score ${props.gameState.current_team_wins}`}</p>\n                    </div>\n                :\n                turnStatus === true ?\n                    <div className=\"round-div\">\n                        <div className=\"team-round-div\">\n                            <p className=\"info-text\">{props.gameState.curr_team.final_turn ? 'Final round - unlimited time' : '30 second rounds'}</p>\n                        </div>\n                    </div>\n                :\n                <p className=\"points-update-text\"> {props.gameState.turns.length === 1 ?\n                    \"First team get ready!\"\n                    :\n                    `Previous team scored ${props.gameState.get_last_wins()} points`\n                    }\n                </p>\n            )}\n\n            {!props.gameState.game_over &&\n            <div className=\"card-div\">\n                {currCards.map((card) => {\n                    return (\n                        playStatus === true && turnStatus === true ?\n                        <div className=\"card-game-div\">\n                            <TinderCard onSwipe={onSwipe} key={card.word} preventSwipe={['up', 'down', 'left', 'right']}>\n                                <div className=\"card\">\n                                    <div className=\"card-category border-top\" style={{backgroundColor: categoryColours[card.category]}}>{card.category}</div>\n                                    <div className=\"card-word\">{card.word}</div>\n                                    <div className=\"card-category border-bottom\" style={{backgroundColor: categoryColours[card.category]}}>{card.category}</div>\n                                </div>\n                            </TinderCard>\n                            <div className=\"game-buttons-div\">\n                                {!props.gameState.curr_team.final_turn && <Button id='defer' className=\"game-button\" onClick={() => deferCard()} variant=\"secondary\">Skip</Button>}\n                                {/* <button id='discard' onClick={() => game.discard_word()} >Discard</button> */}\n                                <Button id='end' className=\"game-button\" onClick={() => clearTime()} variant=\"danger\">End</Button>\n                                <Button id='win' className=\"game-button\" onClick={() => winCard()} variant=\"success\">Win</Button>\n                            </div>\n                        </div>\n                        :\n                        turnStatus === false ?\n                        <TinderCard onSwipe={onReadyTurn} key={'ready'} preventSwipe={['up', 'down', 'left', 'right']}>\n                            <div className=\"card-pending\">\n                                <div className=\"card-category border-top\" style={{backgroundColor: 'grey'}}>*waiting*</div>\n                                <div className=\"card-word-ready\">Swipe right to win card,<br/>swipe left to pass</div>\n                                <div className=\"card-category border-bottom\" style={{backgroundColor: 'grey'}}>*waiting*</div>\n                            </div>\n                        </TinderCard>\n                        :\n                        <div className=\"card-game-div\">\n                            <TinderCard preventSwipe={['up', 'down', 'left', 'right']}>\n                                <div className=\"card\">\n                                    <div className=\"card-category border-top\" style={{backgroundColor: categoryColours[card.category]}}>{card.category}</div>\n                                    <div className=\"card-word\">{card.word}</div>\n                                    <div className=\"card-category border-bottom\" style={{backgroundColor: categoryColours[card.category]}}>{card.category}</div>\n                                </div>\n                            </TinderCard>\n                            <div className=\"game-buttons-div\">\n                                <Button variant=\"primary\" className=\"start-button\" size=\"lg\" onClick={() => setPlayStatus(true)}>Start Timer</Button>\n                            </div>\n                        </div>\n                )})}\n            </div>\n            }\n\n            {props.gameState.game_over ?\n                <div className=\"finish-div\">\n                    <p className=\"helper-text\">🎉 Congratulations 🎉</p>\n                    <p className=\"helper-text\"> {props.gameState.curr_team.name} has won! </p>\n                    <Button onClick={() => restartGame()} variant=\"warning\">Restart</Button>\n                </div>\n                :\n                null\n                // <p className=\"helper-text\"> Swipe right if you've won the card and left to pass/skip </p>\n            }\n\n        </div>\n    )\n}\n\nfunction createGrid(numRows, numCols) {\n    let rows = [];\n    for (let i = 0; i < numRows; i++) {\n        let cols = [];\n        for (let j = 0; j < numCols; j++) {\n            cols.push(undefined);\n        }\n        rows.push(cols);\n    }\n    return rows;\n}\n\n","import './App.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nimport * as main from './api/main';\nimport { useState, useEffect } from \"react\";\nimport GameBoard from './components/GameBoard';\nimport words from './static/words.json';\nimport ToggleButton from 'react-bootstrap/ToggleButton';\nimport ButtonGroup from 'react-bootstrap/ButtonGroup';\nimport Button from 'react-bootstrap/Button';\n\n\nfunction App() {\n  const [game, setGame] = useState(null);\n  const [numTeams, setNumTeams] = useState('2');\n\n  const radios = [\n    { name: '2', value: '2' },\n    { name: '3', value: '3' },\n    { name: '4', value: '4' },\n  ];\n  const restartGame = () => {\n    setGame(main.start_game(words, numTeams));\n    console.log('restarting game');\n  }\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        {/* <img src={articulate} className=\"App-logo\" alt=\"logo\" /> */}\n\n          {game === null &&\n\n          <div className=\"game-options\">\n            <div>\n              Number of Teams\n            </div>\n\n            <ButtonGroup toggle size=\"lg\">\n              {radios.map((radio, idx) => (\n                <ToggleButton\n                  key={idx}\n                  type=\"radio\"\n                  variant=\"secondary\"\n                  name=\"radio\"\n                  value={radio.value}\n                  checked={numTeams === radio.value}\n                  onChange={(e) => setNumTeams(e.currentTarget.value)}\n                  className=\"team-size\"\n                >\n                  {radio.name}\n                </ToggleButton>\n              ))}\n            </ButtonGroup>\n\n            <Button variant=\"primary\" className=\"create-button\" onClick={() => {\n              setGame(main.start_game(words, numTeams, 6));\n            }}> Create Game </Button>\n\n          </div>\n          }\n\n          {game !== null &&\n            <GameBoard gameState={game} numTeams={numTeams} restartGame={restartGame}></GameBoard>\n          }\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}